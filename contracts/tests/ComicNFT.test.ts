import { expect } from 'chai';
import { ethers } from 'hardhat';
import { SignerWithAddress } from '@nomicfoundation/hardhat-ethers/signers';
import { ComicNFT } from '../../typechain-types/contracts/ComicNFT'; // Generated by TypeChain

describe('ComicNFT', function () {
    let comicNFT: ComicNFT;
    let owner: SignerWithAddress;
    let user: SignerWithAddress;

    const MINT_FEE = ethers.parseEther('0.01');
    const TOKEN_URI = 'ipfs://QmTestURI';
    const ROYALTY = 500; // 5%

    beforeEach(async function () {
        [owner, user] = await ethers.getSigners();
        const ComicNFTFactory = await ethers.getContractFactory('ComicNFT');
        comicNFT = (await ComicNFTFactory.deploy()) as ComicNFT;
        await comicNFT.waitForDeployment();
    });

    it('should deploy with correct name and symbol', async function () {
        expect(await comicNFT.name()).to.equal('ComicChain');
        expect(await comicNFT.symbol()).to.equal('COMIC');
    });

    it('should mint an NFT with correct URI, creator, and royalty', async function () {
        await comicNFT.connect(user).mintComic(TOKEN_URI, ROYALTY, { value: MINT_FEE });
        expect(await comicNFT.ownerOf(0)).to.equal(user.address);
        expect(await comicNFT.tokenURI(0)).to.equal(TOKEN_URI);
        expect(await comicNFT.creators(0)).to.equal(user.address);
        expect(await comicNFT.royalties(0)).to.equal(ROYALTY);
        expect(await comicNFT.tokenCounter()).to.equal(1);
    });

    it('should fail to mint with insufficient fee', async function () {
        await expect(
            comicNFT.connect(user).mintComic(TOKEN_URI, ROYALTY, { value: ethers.parseEther('0.005') })
        ).to.be.revertedWithCustomError(comicNFT, 'InsufficientMintingFee');
    });

    it('should fail to mint with invalid royalty', async function () {
        await expect(
            comicNFT.connect(user).mintComic(TOKEN_URI, 1500, { value: MINT_FEE }) // 15% > 10%
        ).to.be.revertedWithCustomError(comicNFT, 'InvalidRoyalty');
    });

    it('should fail to get URI for non-existent token', async function () {
        await expect(comicNFT.tokenURI(999)).to.be.revertedWithCustomError(comicNFT, 'TokenDoesNotExist');
    });

    it('should allow owner to withdraw funds', async function () {
        await comicNFT.connect(user).mintComic(TOKEN_URI, ROYALTY, { value: MINT_FEE });
        const ownerBalanceBefore = await ethers.provider.getBalance(owner.address);
        const tx = await comicNFT.connect(owner).withdraw();
        const receipt = await tx.wait();
        const gasUsed = receipt?.gasUsed ?? 0n;
        const gasPrice = tx.gasPrice ?? 0n;
        const gasCost = gasUsed * gasPrice;
        const ownerBalanceAfter = await ethers.provider.getBalance(owner.address);
        expect(ownerBalanceAfter - ownerBalanceBefore + gasCost).to.equal(MINT_FEE);
    });

    it('should fail to withdraw if not owner', async function () {
        await comicNFT.connect(user).mintComic(TOKEN_URI, ROYALTY, { value: MINT_FEE });
        await expect(comicNFT.connect(user).withdraw()).to.be.revertedWithCustomError(comicNFT, 'OwnableUnauthorizedAccount');
    });

    it('should fail to withdraw if no funds', async function () {
        await expect(comicNFT.connect(owner).withdraw()).to.be.revertedWith('No funds to withdraw');
    });
});